cmake_minimum_required(VERSION 3.21)
project(SemestralProject)

set(CMAKE_CXX_STANDARD 17)

set(LIBRARY_OUTPUT_PATH "${CMAKE_BINARY_DIR}")
set(EXECUTABLE_OUTPUT_PATH "${CMAKE_BINARY_DIR}")

find_package(OpenGL REQUIRED)

## ============= NanoGUI config =================

# Disable building extras we won't need (pure C++ project)
#set(NANOGUI_BUILD_EXAMPLE OFF CACHE BOOL " " FORCE)
set(NANOGUI_BUILD_PYTHON  OFF CACHE BOOL " " FORCE)
set(NANOGUI_INSTALL       ON CACHE BOOL " " FORCE)
# GLAD compile flag to make compilation work cross-platform (on by default with MSVC)
set(NANOGUI_USE_GLAD ON)

# Add the configurations from nanogui
add_subdirectory(include/nanogui)

# For reliability of parallel build, make the NanoGUI targets dependencies
set_property(TARGET glfw glfw_objects nanogui PROPERTY FOLDER "dependencies")

# Various preprocessor definitions have been generated by NanoGUI
add_definitions(${NANOGUI_EXTRA_DEFS})

# On top of adding the path to nanogui/include, you may need extras
include_directories(${NANOGUI_EXTRA_INCS})

# Compile a target using NanoGUI
add_executable(${PROJECT_NAME} src/main.cpp src/windowing.cpp src/utils.cpp src/config.cpp src/render.cpp src/camera.cpp src/world/terrain.cpp src/objects/common.h src/objects/materials.h src/objects/object_loader.cpp src/objects/object_loader.h)

# Lastly, additional libraries may have been built for you.  In addition to linking
# against NanoGUI, we need to link against those as well.


## ============== /NanoGUI config =================

## ============== assimp + glm ====================
add_subdirectory(include/assimp)
add_subdirectory(include/glm)

include_directories(include/stb src)

target_include_directories(${PROJECT_NAME}
        PUBLIC include/assimp/include
        PUBLIC include/glm
        PUBLIC include/stb
        )

target_link_directories(${PROJECT_NAME}
        PRIVATE include/assimp/code
        )

set(ASSIMP_BUILD_TESTS OFF CACHE BOOL " " FORCE)

target_link_libraries(${PROJECT_NAME} PUBLIC nanogui ${NANOGUI_EXTRA_LIBS} assimp)